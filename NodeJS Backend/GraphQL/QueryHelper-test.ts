import {OrderDirection, QueryHelper} from "./QueryHelper";
import {Pool} from "./Schema_Interfaces/Pool";
import {TokenHourData} from "./Schema_Interfaces/TokenHourData";
import {TokenDayData} from "./Schema_Interfaces/TokenDayData";
import {print_json_tree} from "../Utils/print_json_tree";
import {Token} from "./Schema_Interfaces/Token";

async function test()
{
    //let qh: QueryHelper = new QueryHelper();

    //const result = await qh.getPools(5000, "volumeUSD", OrderDirection.desc );
    //console.log(`There are ${result.length} pools.`);

    //for(let pool of result) {
    //    console.log(`
    //    Pool ID: ${pool['id']}
    //    1 ${pool['token0']['symbol']} is worth ${pool['token1Price']} ${pool['token1']['symbol']}
    //    1 ${pool['token1']['symbol']} is worth ${pool['token0Price']} ${pool['token0']['symbol']}`);
    //}
    //
    //let pool_match_list: object[] = await qh.getPoolIdByCoinMatch(['WETH','DAI'],1000);
    //for(let match of pool_match_list) {
    //    let match_id = match['id'];
    //    console.log(`Matched pool id is ${match_id}`);
    //}
    //await checkForDuplicatesById(pool_match_list);
    //let before = moment('2022-01-13T12:00:00Z')
    //let  = moment(new Date());
    //console.log(now.tz('America/New_York').format('MM/DD/YYYY h:ma z'));
    //testGetPoolsByID(result);
    //testGetTokenHourDatas(5);
    //testGetTokenDayDatas(100);
    // trying to get price of weth usd, it depends if weth is defined as token0 or token1 in the match.
   //await testGetTokens(5000,'PLU');
    //await testGetPools(10, 'volumeUSD', OrderDirection.desc);
    await testPoolsByCoinGeckoMatch(1000, "volumeUSD");
   //testGetTokenHourDatas(10);
}

// return string is print data generated by the test.
async function testGetTokens(first:number, token_symbol:string = "", orderBy:string = 'symbol', direction:OrderDirection = OrderDirection.desc)
{
    const qh = new QueryHelper();
    const tokens:Token[] =
        await qh.getTokens(first, orderBy, direction);
    let output_str:string = "";
    if(token_symbol != "")
    {
        let found_it:boolean = false;
        for(let token of tokens) {
            if(token.symbol === token_symbol) {
                found_it = true;
                output_str += `
                    Found token ${token.symbol}!`;
            }
        }
        if(!found_it) output_str += `
            Searched ${first} tokens.
            Couldn't find token ${token_symbol}`
    }
    else {
        for (let i = 0; i < tokens.length; i++) {
            let token = tokens[i];
            output_str += `
        
            Token name: ${token.name}
            Token symbol: ${token.symbol}
            Token id: ${token.id}
            White list pools:`
            const pools: Pool[] = token.whitelistPools;
            for (let j = 0; j < pools.length; j++) {
                let pool: Pool = pools[j];
                output_str += `
                ${pool.id}`
            }
        }
    }

    console.log(output_str);
}
async function testGetTokenHourDatas(how_many_print:number,symbol_to_search:string = ""):Promise<string>
{
   const qh = new QueryHelper();
   const tokenHourDatas: TokenHourData[] =
       await qh.getTokenHourData(how_many_print, 'volumeUSD', OrderDirection.desc);
   // prepare some selections for pretty printing:
   let list_print_str: String = ``;
   if(symbol_to_search != "")
   {
       let found_item:boolean = false;
       for(let hour_datas of tokenHourDatas)
       {
           if(hour_datas.token?.symbol === symbol_to_search)
           {
               found_item = true;
               list_print_str +=
                   `Found it!
                       Token: ${hour_datas.token?.symbol}
                            id: ${hour_datas.token?.id }
                            priceUSD: ${hour_datas.priceUSD}
                            volumeUSD: ${hour_datas.volumeUSD}
                            number of pools: ${hour_datas.token?.poolCount }
                     `
           }
       }
       if(!found_item) {
           list_print_str += `Could not find token with symbol: ${symbol_to_search}`
       }
   }
   else {
       for (let i: number = 0; i < how_many_print; i++) {
           list_print_str +=
               `Token: ${tokenHourDatas[i].token?.symbol}
            id: ${tokenHourDatas[i].token?.id}
            priceUSD: ${tokenHourDatas[i].priceUSD}
            volumeUSD: ${tokenHourDatas[i].volumeUSD}
            number of pools: ${tokenHourDatas[i].token?.poolCount}
         `
       }
   }
   const message:string =
    ` tokenHourDatas:
    `+ `total items: ${tokenHourDatas.length}
    `+ `${list_print_str.toString()} 
    `;
    console.log(message);
    return message;
}

// return string is print data generated by the test.
async function testGetTokenDayDatas(how_many_print:number):Promise<string>
{
    const qh = new QueryHelper();
    const tokenDayDatas: TokenDayData[] =
        await qh.getTokenDayData(100, 'volumeUSD', OrderDirection.desc);
    // prepare some selections for pretty printing:
    let list_print_str: String = ``;
    for(let i:number = 0; i < how_many_print; i++ ){
        list_print_str +=
            `Token: ${tokenDayDatas[i].token?.symbol}
            id: ${tokenDayDatas[i].token?.id }
            priceUSD: ${tokenDayDatas[i].priceUSD}
            volumeUSD: ${tokenDayDatas[i].volumeUSD}
            number of pools: ${tokenDayDatas[i].token?.poolCount }
         `
    }

    const message:string =
        ` tokenDayDatas:
    `+ `total items: ${tokenDayDatas.length}
    `+ `${list_print_str.toString()} 
    `;
    console.log(message);
    console.log(print_json_tree(tokenDayDatas[0]," "))
    return message;
}


async function testGetPoolsByID(pools:Pool[]): Promise<Pool[]>
{
    const qh = new QueryHelper();
    let id_list = qh.getIDsFromPoolList(pools);
    let fetched_pools:Pool[] = await qh.getPoolsByID(id_list);
    //console.log("id_list: " + "\n" +
    //    id_list + "\n" +
    //    "fetched_pools:" + '\n' );
    //console.log(fetched_pools);
    console.log("Pools length is: " + fetched_pools.length);
    return fetched_pools;
}

async function testGetPools(first: number, orderBy:string, direction:OrderDirection)
{
    let data:Pool[] = await new QueryHelper().getPools(first, orderBy, direction);
    for(let pool of data)
    {
        console.log(pool.print());
    }
}
async function testPoolsByCoinGeckoMatch(first:number, orderBy:string, direction:OrderDirection = OrderDirection.desc)
{
    let data:Pool[] = await new QueryHelper().getPoolsThatMatchCoinGecko(first, orderBy, direction,);
    for(let pool of data)
    {
        console.log(pool.print());
    }
    console.log(`number of pools ${data.length}`)
}
// Test if queries ever return duplicates:
async function checkForDuplicatesById(list:Pool[]): Promise<void>
{
    let duplicates_found:Boolean = false;
    let list_copy = [...list];

    list_copy = list_copy.sort(new QueryHelper().sort_pools_by_id_func);
    //length must be 2 or greater because we are popping and comparing
    while(list_copy.length > 1)
    {
        const item: object | undefined = list_copy.pop();
        // item shouldn't be null, compiler keeps complaining though
        // @ts-ignore
        if(item['id'] === list_copy[list_copy.length -1]['id']){
            duplicates_found = true;
            throw new Error("Found duplicates ids in list. Something may or may not be wrong with that.");
        }
    }
    if(!duplicates_found) console.log('No duplicate pool ids found.');

}



test();